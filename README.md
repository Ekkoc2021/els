## 简单的说明

python选修课大作业

为什么写俄罗斯方块?

- 我小时候玩过这个游戏,想按照自己的想法做一个俄罗斯方块的游戏
- 第一次使用pygame和第一次写游戏,俄罗斯方块实现难度不大,基本都是在绘制方块,逻辑也相对简单

用到了那些库?

- pygame:绘制直线,绘制方块,绘制文字,监听机制
- pickle:python自带的一个序列化的库,用于持久化数据到硬盘和反序列化
- random:用于随机获取方块部分的代码的实现

绘制的界面地址:https://js.design/f/M_udEd?p=ITCRjt7NTG
仓库地址:https://github.com/Ekkoc2021/els

大部分程序界面和ui数据没有太大差别,除了游戏背景制作的时候有较大的更改,改动如下面这张图

![1665292568852](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1665292568852.png)

总共合并了5次,每一次合并都有很大的改动,第4次是最难的部分
前3次就照着ui的数据写
难度最大是第4次:完成游戏的核心部分,核心部分的添加是从ee74746这个版本之后开始添加的,也就是10月2号之后
第5次:整合前4次
我本身没有太多经验,全凭自己的想法写,大部分代码只考虑实现没对效率和内存做过多思考,代码可读性也一般,特别是核心部分的前3个方块类的书写

## 功能介绍

### 程序界面

提供了两种模式选择:竞技模式游戏的数据是被记录,创造模式的游戏数据不被记录,创造模式游戏过程中可以根据需要调整方块的种类

![1665293873617](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1665293873617.png)



### 竞技模式选择界面

可以查看排名,开始新游戏,继续上次的游戏(只会保存上次没有结束的游戏),查看排名,退出竞技模式

![1665294929607](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1665294929607.png)

### 新游戏==>速度选择界面

不同的速度对应着不同的加分

![1665295059406](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1665295059406.png)

### 设置

点击对应按钮,按钮颜色对应着对应的界面颜色,然后保存;实际界面还有一个取消

![1665298647696](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1665298647696.png)

## 游戏核心实现

游戏核心部分是用面向对象来实现的

### 方块的抽象类

一个方块只要能够完成对以下的方块实现,按照一定的顺序组装就能够动起来

```python
class AbstractBlock():

    #在画板上绘制出该方块
    @abstractmethod
    def drawBlock(self,screen,allcolors):
        pass
    #方块水平移动:改变方块x坐标
    @abstractmethod
    def horiMove(self, gameD, dire):
        pass
    #方块向下移动,改变y坐标,无法移动时返回False,表示该方块生命周期结束
    @abstractmethod
    def downward(self, gameD, speed):
        pass
    
    #组装方块移动: # 返回的T表示方块依然存活,F表示方块已经消亡
    @abstractmethod
    def blockMove(self, speed, gameD, dire):
        pass

    #用于对象消亡时写入数据的方法:向gamedata写入数据
    @abstractmethod
    def writeData(self,gameD):
        pass

    #在预告栏里面展示出本方块
    @abstractmethod
    def drawInForeshow(self, screen, allcolors):
        pass

    #改变图像形状,更改方块图形
    @abstractmethod
    def changeShape(self,gameD):
        pass
```

第一个图像实现的使用:绘制整体图像,碰撞判断的时候是单个正方形
剩余图像实现用了一个定位点,判断绘制的时候根据定位点生成其他点去判断

### 游戏内存数据的抽象类

数据类应该包含

```python
class abstractGameData:
    
	'''
    写入数据:方块生命周期结束需要写入数据,提供坐标和颜色即可
    '''
    def writeDate(self, x, y, co):
        pass
    
    '''
    保存数据到硬盘
    '''
    def saveData(self):
        pass
    
    '''
    清空数据
    '''
    def ReSetGameData(self):
        pass
    
    '''
    判断得分与否,得分后消除对应行,重置gamedata的数据
    '''
    @abstractmethod
    def isWin(self):
        pass

    '''
      绘制出gameData的数据
    '''
    @abstractmethod
    def Paint(self,screen):
        pass

    '''
    返回gamedata[i][j][0]的坐标,j>0
    '''
    @abstractmethod
    def getColor(self,i,j):
        pass

    '''
    返回gamedata[i][j][1],j>0,也就是返回坐标
    '''
    @abstractmethod
    def getLoation(self, i, j):
        pass
    '''
    返回这组坐标在gamedata的映射
    '''
    @abstractmethod
    def getMapping(self,x,y):
        pass
    '''
    返回这组坐标在gamedata写入对应颜色数据
    '''
    @abstractmethod
    def writeDate(self,x,y,co):
        pass游戏
```

一开始数据类中的有些方法是没有的,是后来写第4个图像写到一半的的时候,发现太麻烦且调试难度大才补上去:比如前三个由坐标的索引的映射每次都是边写边算,后来抽取成方法封装到了数据类中

### 数据存储说明

```python
#游戏时间,游戏分数,队列:存放当前活动方块,顶部的预告栏出现的阈值,记录当前游戏的速度
['2022-10-09 16:52:16', 0, [None, None, None], 0, 0]
#这一行是否被访问(是否有数据,加快消除方块),[颜色索引,对应位置的坐标](-1表示为空)
[False, [-1, [80, 40]], [-1, [120, 40]], [-1, [160, 40]], [-1, [200, 40]], [-1, [240, 40]], [-1, [280, 40]], [-1, [320, 40]], [-1, [360, 40]]]
[False, [-1, [80, 80]], [-1, [120, 80]], [-1, [160, 80]], [-1, [200, 80]], [-1, [240, 80]], [-1, [280, 80]], [-1, [320, 80]], [-1, [360, 80]]]
[False, [-1, [80, 120]], [-1, [120, 120]], [-1, [160, 120]], [-1, [200, 120]], [-1, [240, 120]], [-1, [280, 120]], [-1, [320, 120]], [-1, [360, 120]]]
[False, [-1, [80, 160]], [-1, [120, 160]], [-1, [160, 160]], [-1, [200, 160]], [-1, [240, 160]], [-1, [280, 160]], [-1, [320, 160]], [-1, [360, 160]]]
[False, [-1, [80, 200]], [-1, [120, 200]], [-1, [160, 200]], [-1, [200, 200]], [-1, [240, 200]], [-1, [280, 200]], [-1, [320, 200]], [-1, [360, 200]]]
[False, [-1, [80, 240]], [-1, [120, 240]], [-1, [160, 240]], [-1, [200, 240]], [-1, [240, 240]], [-1, [280, 240]], [-1, [320, 240]], [-1, [360, 240]]]
[False, [-1, [80, 280]], [-1, [120, 280]], [-1, [160, 280]], [-1, [200, 280]], [-1, [240, 280]], [-1, [280, 280]], [-1, [320, 280]], [-1, [360, 280]]]
[False, [-1, [80, 320]], [-1, [120, 320]], [-1, [160, 320]], [-1, [200, 320]], [-1, [240, 320]], [-1, [280, 320]], [-1, [320, 320]], [-1, [360, 320]]]
[False, [-1, [80, 360]], [-1, [120, 360]], [-1, [160, 360]], [-1, [200, 360]], [-1, [240, 360]], [-1, [280, 360]], [-1, [320, 360]], [-1, [360, 360]]]
[False, [-1, [80, 400]], [-1, [120, 400]], [-1, [160, 400]], [-1, [200, 400]], [-1, [240, 400]], [-1, [280, 400]], [-1, [320, 400]], [-1, [360, 400]]]
[False, [-1, [80, 440]], [-1, [120, 440]], [-1, [160, 440]], [-1, [200, 440]], [-1, [240, 440]], [-1, [280, 440]], [-1, [320, 440]], [-1, [360, 440]]]
[False, [-1, [80, 480]], [-1, [120, 480]], [-1, [160, 480]], [-1, [200, 480]], [-1, [240, 480]], [-1, [280, 480]], [-1, [320, 480]], [-1, [360, 480]]]
[False, [-1, [80, 520]], [-1, [120, 520]], [-1, [160, 520]], [-1, [200, 520]], [-1, [240, 520]], [-1, [280, 520]], [-1, [320, 520]], [-1, [360, 520]]]
[False, [-1, [80, 560]], [-1, [120, 560]], [-1, [160, 560]], [-1, [200, 560]], [-1, [240, 560]], [-1, [280, 560]], [-1, [320, 560]], [-1, [360, 560]]]
[False, [-1, [80, 600]], [-1, [120, 600]], [-1, [160, 600]], [-1, [200, 600]], [-1, [240, 600]], [-1, [280, 600]], [-1, [320, 600]], [-1, [360, 600]]]
[False, [-1, [80, 640]], [-1, [120, 640]], [-1, [160, 640]], [-1, [200, 640]], [-1, [240, 640]], [-1, [280, 640]], [-1, [320, 640]], [-1, [360, 640]]]
[False, [-1, [80, 680]], [-1, [120, 680]], [-1, [160, 680]], [-1, [200, 680]], [-1, [240, 680]], [-1, [280, 680]], [-1, [320, 680]], [-1, [360, 680]]]
```



### 组装

绘制顶部提示的方块(queue[1].drawBlock)==>绘制右边提示的方块(queue[2].drawInForeshow)

==>绘制当前活动的方块(queue[0].drawBlock)==>改变方块位置(queue[0].blockMove)判断是否消亡写入数据

==>得分判断(gameD.isWin())

```python
	    iniTdraw(screen, colorsOp, grade)#绘制游戏背景
    	#方块提示1:根据阈值判断是否绘制顶部方块:设置为120
        if gameD.gameData[0][3]>120:
            queue[1].drawBlock(screen, allcolors)#绘制提示方块
        else:
            gameD.gameData[0][3]+=1#阈值+1
        #方块降落
         #从队列中取出方块,
        #在预告区预告第三个图形
        queue[2].drawInForeshow( screen, allcolors)#在右边提示区域绘制队列第三个图像
        queue[0].drawBlock(screen, allcolors)#绘制当前正在活动的方块
        live=queue[0].blockMove(speed, gameD, dirc)#根据监听,进行方块移动,同时返回方块是否存活
        if not live:#如果方块消亡,向queue中添加方块,并为方块重新赋值
            #写入方块数据,同时获取新方块
            queue[0]. writeData(gameD)
            queue.append(factory.getRandomBlock())
            gameD.gameData[0][3]=1
            queue.pop(0)
        dirc=0#左右移动方向复位
        gameD.Paint(screen, allcolors)
        pygame.display.update()#刷新显示
        #写完数据:第3行有方块就直接退出游戏,超出了游戏的范围
        if gameD.gameData[3][0]:
            GameOver(screen, colorsOp, gameD)
            return isOver
        if gameD.isWin():
            #5,如果得分了重绘游戏区域
            iniTdraw(screen, colorsOp,gameD.gameData[0][1])
            gameD.Paint(screen, allcolors)
        #得分重绘后如果第4行有数据直接退出游戏,满了
        if gameD.gameData[4][0]:
            GameOver(screen,colorsOp,gameD)
            return isOver
```

